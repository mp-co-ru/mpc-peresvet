methods (методы)
~~~~~~~~~~~~~~~~
Методы используются для вычислений значений тегов.
Значение тега может приходить из внешнего источника, а может быть вычислено,
для чего необходимо:

1. Написать метод для вычисления значений тега.
2. Привязать этот метод к тегу, указав, какие события будут инициировать
   расчёт.

Создание вычислительного метода тега
""""""""""""""""""""""""""""""""""""
Рассмотрим создание вычислительного метода тега на следующем примере:
допустим, у нас есть объект "комната" и в этой комнате - два потребителя
электроэнергии: освещение и телевизор. С каждого потребителя мы можем получать
количество потреблённой энергии в киловатт-часах.

Комната же имеет тег "Суммарная потреблённая энергия", значение которого
должно вычисляться как сумма потреблённой энергии освещением и телевизором,
причём значение этого тега должно пересчитываться каждый раз, когда мы
получаем новое значение потреблённой энергии от потребителей электроэнергии
в комнате.

**Подготовка иерархии объектов и тегов**
Создание объектов и тегов не будем здесь детально описывать - см.
соответствующие разделы документации.

Покажем иерархию созданных объектов и тегов:

.. figure:: pics/methods_01.png
    :align: center

    Объекты

**Создание расчётного метода**
Опишем процесс создания расчётного метода для тега
"Суммарная потреблённая энергия" объекта "Комната".

.. note::
   Для управления распределёнными вычислениями используются библиотеки
   `patio <https://pypi.org/project/patio/>`_ и
   `patio_rabbitmq <https://pypi.org/project/patio-rabbitmq/>`_.

Создадим скрипт на языке **python**, предварительно установив пакеты
"patio" и "patio_rabbitmq":

.. code-block:: python
   :linenos:

   import asyncio
   from patio import Registry, AsyncExecutor
   from patio_rabbitmq import RabbitMQBroker

   rpc = Registry(project="methods_app", auto_naming=False)

   @rpc("sum")
   async def sum(a: dict, b: dict) -> float:
      try:
         val_a = a["data"][0]["data"][0][0]
         val_b = b["data"][0]["data"][0][0]
         res = (val_a, 0)[val_a is None]+(val_b, 0)[val_b is None]
      except Exception as ex:
         print(f"Ошибка: {ex}")
         return None

      return res

   async def main():
      async with AsyncExecutor(rpc, max_workers=16) as executor:
         async with RabbitMQBroker(
               # измените параметры подключения к RabbitMQ
               executor, amqp_url="amqp://uid:pwd@localhost/",
         ) as broker:
               await broker.join()

   if __name__ == "__main__":
      asyncio.run(main())

.. attention::

   1. Отметим, что расчётный метод регистрируется в системе под именем "sum":
      ``@rpc("sum")`` (строка 7).
   2. Выбор значений (строки 10-11) будет объяснён ниже.

.. attention::

   Если в процессе вычисления метода происходит какая-либо ошибка,
   либо метод не должен возвращать новое значение тега
   (к примеру, в процессе расчёта выяснилось, что нового значения у тега нет),
   то метод должен вернуть словарь с ключом ``error``. Значение этого ключа -
   любое.

Созданный нами расчётный метод имеет два входных параметра: ``a`` и ``b``.

**Создание узла для расчётного метода**
Теперь нам необходимо создать узел, описывающий расчётный метод для тега
"Суммарная потреблённая энергия".

При создании узла мы должны указать:

1. зарегистрированное имя метода ("sum");
2. на вход метод принимает два параметра;
3. в качестве значений параметров должны передаваться значения тегов
   "Потреблённая энергия" объектов "Освещение" и "Телевизор";
4. метод должен инициироваться изменением двух вышеуказанных тегов.

Соответственно, получаем такое тело запроса, который мы должны выполнить
для создания узла метода:

.. attention::

   Для удобства предположим, что:

   1. id тега "Суммарная потреблённая энергия" = 1
   2. id "Освещение --> Потреблённая энергия" = 2
   3. id "Телевизор --> Потреблённая энергия" = 3

.. code-block:: python
   :linenos:

   # request: POST http://<srv>/v1/methods

   # body:
   {
      # id вычисляемого тега ("Суммарная потреблённая энергия")
      "parentId": "1",
      "attributes": {
         # зарегистрированное имя метода
         "cn": "Сумма",
         "prsMethodAddress": "sum"
      },
      # id тегов "Потреблённая энергия" объектов "Освещение" и "Телевизор"
      "initiatedBy": ["2", "3"],
      "parameters": [
         {
            "attributes": {
               "prsJsonConfigString": "{\"tagId\": \"2\"}"
            }
         },
         {
            "attributes": {
               "prsJsonConfigString": "{\"tagId\": \"3\"}"
            }
         }
      ]
   }

Таким образом, имя метода передается в атрибуте ``prsMethodAddress``
(строка 10).

В рассматриваемом примере порядок следования параметров при вызове метода
не важен. Если же при вызове метода необходимо учитывать порядок параметров,
то в атрибутах параметра необходимо передать атрибут ``prsIndex``. При вызове
метода параметры будут отсортированы по этому атрибуту в порядке возрастания
и переданы методу.

Запрос с учётом порядка следования параметров:

.. code-block:: python
   :linenos:

   # request: POST http://<srv>/v1/methods

   # body:
   {
      # id вычисляемого тега ("Суммарная потреблённая энергия")
      "parentId": "1",
      "attributes": {
         # зарегистрированное имя метода
         "cn": "Сумма",
         "prsMethodAddress": "sum"
      },
      # id тегов "Потреблённая энергия" объектов "Освещение" и "Телевизор"
      "initiatedBy": ["2", "3"],
      "parameters": [
         {
            "attributes": {
               "prsJsonConfigString": "{\"tagId\": \"2\"}",
               "prsIndex": 1
            }
         },
         {
            "attributes": {
               "prsJsonConfigString": "{\"tagId\": \"3\"}",
               "prsIndex": 2
            }
         }
      ]
   }

Атрибут ``prsJsonConfigString`` содержит, фактически, запрос для команды
``data/get``. При вызове метода в этот запрос автоматически подставляется
флаг ``finish``, который равен метке времени нового значения тега-инициатора
расчёта. Именно поэтому в вычислительном методе такой сложный выбор значений
(см. выше).
